# -*- coding: utf-8 -*-
"""ICMP Ping.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14a8CI1jkaqHmSLK9fowC22WqaT8-RnYD
"""

def get_ip():
    local_host = gethostname()
    return gethostbyname(local_host)

local_host = get_ip()
print(local_host)

from socket import *
import os
import sys
import struct
import time
import select
import binascii

ICMP_ECHO_REQUEST = 8  # ICMP type for echo request
ICMP_ECHO_REPLY = 0    # ICMP type for echo reply


def checksum(source_string):
    csum = 0
    countTo = (len(source_string) // 2) * 2
    count = 0

    while count < countTo:
        thisVal = source_string[count + 1] * 256 + source_string[count]
        csum = csum + thisVal
        csum = csum & 0xffffffff
        count += 2

    if countTo < len(source_string):
        csum = csum + source_string[-1]
        csum = csum & 0xffffffff

    csum = (csum >> 16) + (csum & 0xffff)
    csum = csum + (csum >> 16)
    answer = ~csum
    answer = answer & 0xffff
    answer = answer >> 8 | (answer << 8 & 0xff00)

    return answer


def receiveOnePing(mySocket, ID, timeout, destAddr):
    timeLeft = timeout

    while 1:
        startedSelect = time.time()
        whatReady = select.select([mySocket], [], [], timeLeft)
        howLongInSelect = (time.time() - startedSelect)

        if not whatReady[0]:  # Timeout
            return None, "Request timed out."

        timeReceived = time.time()
        recpacket, addr = mySocket.recvfrom(1024)
        # Fill in start
        data = recpacket[28:]
        icmpHeader = recpacket[20:28]
        print(f"data of echo reply: {data.hex()}")
        type, code, checksum, p_ID, sequence = struct.unpack("bbHHh", icmpHeader)

        print(f"components of Echo reply header: Type: {type}, Code: {code} , Checksum: {checksum}, ID: {p_ID}, Sequence Number: {sequence} ")

        if type == ICMP_ECHO_REPLY and p_ID == ID:
            rtt = (timeReceived - struct.unpack("d", recpacket[28:28 + struct.calcsize("d")])[0]) * 1000
            return rtt, None

        elif type == 3:  # Destination unreachable
            error_message = {
                0: "Destination Network Unreachable",
                1: "Destination Host Unreachable",
            }.get(code, "Unreachable Error Code: " + str(code))
            return None, error_message
        # Fill in end

        timeLeft = timeLeft - howLongInSelect

        if timeLeft <= 0:
            return None, "Request timed out."


def sendOnePing(mySocket, destAddr, ID):
    # Header is type (8), code (8), checksum (16), id (16), sequence (16)
    myChecksum = 0


    Header = struct.pack("bbHHh", ICMP_ECHO_REQUEST, 0, 0, ID, 1)
    data = struct.pack("d", time.time())

    myChecksum = checksum(Header + data)

    if sys.platform == 'darwin':
        myChecksum = htons(myChecksum) & 0xffff
    else:
        myChecksum = htons(myChecksum)

    Header = struct.pack("bbHHh", ICMP_ECHO_REQUEST, 0, myChecksum, ID, 1)

    type, code, checksum_pr, p_ID, sequence = struct.unpack("bbHHh", Header)
    print(f"data of Echo request: {data.hex()}")
    print(f"components of Echo request header: {type}, Code: {code} , Checksum: {checksum_pr}, ID: {p_ID}, Sequence Number: {sequence} ")

    packet = Header + data
    # AF_INET address must be tuple, not str
    mySocket.sendto(packet, (destAddr, 1))


def doOnePing(destAddr, timeout):
    icmp = getprotobyname("icmp")


    mySocket = socket(AF_INET, SOCK_RAW, icmp)

    myID = os.getpid() & 0xFFFF
    sendOnePing(mySocket, destAddr, myID)
    rtt, error = receiveOnePing(mySocket, myID, timeout, destAddr)
    mySocket.close()

    return rtt, error


def ping(host, count=4, timeout=1):

    dest = gethostbyname(host)
    print(f"Pinging {host} [{dest}] with Python ICMP:")

    stats = {
        "sent": 0,
        "received": 0,
        "min_rtt": float('inf'),
        "max_rtt": float('-inf'),
        "total_rtt": 0,
    }

    for i in range(count):
        stats["sent"] += 1
        rtt, error = doOnePing(dest, timeout)

        if rtt is not None:
            stats["received"] += 1
            stats["min_rtt"] = min(stats["min_rtt"], rtt)
            stats["max_rtt"] = max(stats["max_rtt"], rtt)
            stats["total_rtt"] += rtt
            print(f"Reply from {dest}: time={rtt:.2f} ms")
            print("")
        else:
            print(f"Error: {error}")
            print("")

        time.sleep(1)

    packet_loss = ((stats["sent"] - stats["received"]) / stats["sent"]) * 100
    avg_rtt = stats["total_rtt"] / stats["received"] if stats["received"] > 0 else 0

    print("\nPing statistics:")
    print(f"    Packets: Sent = {stats['sent']}, Received = {stats['received']}, Lost = {stats['sent'] - stats['received']} {packet_loss:.1f}% loss)")
    if stats['received'] > 0:
        print(f"Approximate round trip times in milli-seconds:")
        print(f"    Minimum = {stats['min_rtt']:.2f} ms, Maximum = {stats['max_rtt']:.2f} ms, Average = {avg_rtt:.2f} ms")


ping("google.de")



